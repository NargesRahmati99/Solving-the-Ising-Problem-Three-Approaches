# -*- coding: utf-8 -*-
"""Solving Ising problem using Gaussian boson samling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FSTULlrGMFB_G2vmjt4p7npGT_lNnsBh
"""

!pip install xanadu-cloud-client

!xcc config set REFRESH_TOKEN "eyJhbGciOiJIUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIwYTdjOGE5Yi1lMzdkLTQ0MzItOTU2OC0xNzI3YzEwNmYyMzEifQ.eyJpYXQiOjE3MjAzODUyNTksImp0aSI6IjdlMWM5OWM2LTFjNTAtNGY2Ny1iOWEwLTcxNzc1NmUyMDlhZSIsImlzcyI6Imh0dHBzOi8vcGxhdGZvcm0ueGFuYWR1LmFpL2F1dGgvcmVhbG1zL3BsYXRmb3JtIiwiYXVkIjoiaHR0cHM6Ly9wbGF0Zm9ybS54YW5hZHUuYWkvYXV0aC9yZWFsbXMvcGxhdGZvcm0iLCJzdWIiOiI0M2Q5NGM3NC1hYWYwLTQwNjUtOGE3MS04YjljODYxNmY3OTIiLCJ0eXAiOiJPZmZsaW5lIiwiYXpwIjoicHVibGljIiwic2Vzc2lvbl9zdGF0ZSI6IjA5ZTE3YmNjLTk4MDktNDk1YS1iYWYwLTgwOWI1MDEwNzNhMyIsInNjb3BlIjoicHVibGljLXJvbGVzIHByb2ZpbGUgZW1haWwgb2ZmbGluZV9hY2Nlc3MiLCJzaWQiOiIwOWUxN2JjYy05ODA5LTQ5NWEtYmFmMC04MDliNTAxMDczYTMifQ.WaGp-7S2KcQkM_UFoPKYTboJ-6kxiHEWOnvMSncuiME"

!xcc ping

pip install strawberryfields --upgrade

import strawberryfields as sf
from strawberryfields import ops
import numpy as np
from scipy.linalg import qr

# Set a constant seed for reproducibility
random_seed = 42
np.random.seed(random_seed)

# Define the Ising model parameters
J = np.random.uniform(-1, 1, (10, 10))
J = (J + J.T) / 2  # Ensure the matrix is symmetric

# Create a 10-mode Gaussian boson sampling circuit
n_modes = 10
cutoff = 400

# Initialize the engine and program
eng = sf.Engine('gaussian')
prog = sf.Program(n_modes)

def random_unitary(n_modes):
    """Generates a random unitary matrix."""
    A = np.random.randn(n_modes, n_modes) + 1j * np.random.randn(n_modes, n_modes)
    Q, R = qr(A)
    return Q

with prog.context as q:
    # Apply random squeezing to each mode
    for i in range(n_modes):
        ops.Sgate(np.random.uniform(0, 1)) | q[i]

    # Apply a random interferometer to entangle the modes
    U = random_unitary(n_modes)
    print("Random unitary matrix U:\n", U)
    ops.Interferometer(U) | q

# Run the simulation
results = eng.run(prog, shots=1000, cutoff_dim=cutoff)

# Extract the samples
samples = results.samples
print("Number of samples generated:", samples.size)

# Calculate the Ising Hamiltonian for each sample
def calculate_energy(sample, J):
    energy = 0
    for i in range(len(sample)):
        for j in range(i, len(sample)):
            energy += J[i, j] * sample[i] * sample[j]
    return energy

if samples.size > 0:
    energies = [calculate_energy(sample, J) for sample in samples]

    # Find the sample with the minimum energy
    min_energy_index = np.argmin(energies)
    ground_state = samples[min_energy_index]
    ground_energy = energies[min_energy_index]

    print(f"Ground state: {ground_state}")
    print(f"Ground energy: {ground_energy}")
else:
    print("No samples generated within the cutoff. Try increasing cutoff_dim.")

